/*
 * TODOs at this point:
 * 1. Do more cleanup and polishing of the Stock UM so that it can be a shiny
 *    example of a great starting point
 * 2. Find out what my options are for profiling (if any)
 * 3. Get more low hanging fruit off this simple version
 * 4. Ask ChatGPT what it can do for me.
 * 5. Figure out how to determine the size of a file more easily (that is a quick boost in speed)
 * 6. Consider more aggressive design solutions for optimizing the program (Is sequencing the best way to do things?)
 * 7. After all of the above is rock solid, start thinking about x86 assembly. This of course will require a lot of setup
 *    Either I have to put the project back on the department servers or I have to use a docker image or some VM
 *    Basically I have to figure out how to run this program on Linux, umdump it, and then begin the slow and tedious process
 *    of figuring how to do all this shit in assembly. I think this will be a monumental pain in the ass.
 * 8. If by the grace of god I figure out how to do this for x86, the final boss will be figuring out how to do this
 *    locally on my ARM machine. This is why the fully functional natively implemented program is so important: I have to have
 *    control over every last byte with the asssembly, so I have to take extreme ownership of everything.

 */

/* More ideas:
 * Look at the profiling assignment for more ideas of how to get the low hanging fruit
 * The segments should be in global memory. The registers should be in global memory.
 * Functions should be static and inline, if they are even separated at all.
 * 
 * Also, don't neglect the IO module again. That was what cost us Excellent on everything for the profiling assignments.
 * */